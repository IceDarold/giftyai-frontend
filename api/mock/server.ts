import { MOCK_DB_GIFTS } from './data';
import { GiftDTO, RecommendationResponseDTO } from '../dto/types';
import { QuizAnswers, Gift, UserProfile, CalendarEvent } from '../../domain/types';

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

const toDTO = (gift: Gift): GiftDTO => ({
  id: gift.id,
  title: gift.title,
  description: gift.description || null,
  price: gift.price || null,
  currency: gift.currency || 'RUB',
  image_url: gift.imageUrl || null,
  product_url: gift.productUrl || `https://market.yandex.ru/search?text=${encodeURIComponent(gift.title)}`,
  merchant: gift.merchant || 'Market',
  category: gift.category || null,
  tags_list: gift.tags,
  ai_reason: gift.reason,
  reviews_data: gift.reviews ? {
    average_rating: gift.reviews.rating,
    total_count: gift.reviews.count,
    source_platform: gift.reviews.source,
    top_highlights: gift.reviews.highlights,
    reviews_list: gift.reviews.items.map(r => ({
      id: r.id,
      author_name: r.author,
      rating_val: r.rating,
      created_at: r.date,
      content: r.text,
      tag_label: r.tag,
      photo_urls: r.photos
    }))
  } : undefined
});

const DEFAULT_PROFILE: UserProfile = {
  name: '–î—Ä—É–≥',
  avatarEmoji: 'üòé',
  level: '–ù–æ–≤–∏—á–æ–∫',
  events: []
};

export const MockServer = {
  async getGifts(params?: { limit?: number; tag?: string; category?: string }): Promise<GiftDTO[]> {
    await delay(300);
    let results = [...MOCK_DB_GIFTS];
    
    if (params?.category) {
        results = results.filter(g => g.category?.toLowerCase() === params.category?.toLowerCase());
    }

    if (params?.tag) {
        results = results.filter(g => g.tags?.some(t => t.toLowerCase().includes(params.tag!.toLowerCase())));
    }

    if (params?.limit) {
        results = results.slice(0, params.limit);
    }
    
    // If filtering returned nothing (e.g. strict tag match fail), return generic mix to avoid empty screen
    if (results.length === 0) {
        results = MOCK_DB_GIFTS.slice(0, params?.limit || 10);
    }

    return results.map(toDTO);
  },

  async getGiftsByIds(ids: string[]): Promise<GiftDTO[]> {
    await delay(400);
    return MOCK_DB_GIFTS.filter(g => ids.includes(g.id)).map(toDTO);
  },

  async getGiftById(id: string): Promise<GiftDTO> {
    await delay(200);
    const gift = MOCK_DB_GIFTS.find(g => g.id === id);
    if (!gift) throw new Error("Gift not found");
    return toDTO(gift);
  },

  async getSimilarGifts(id: string): Promise<GiftDTO[]> {
    await delay(400);
    const currentGift = MOCK_DB_GIFTS.find(g => g.id === id);
    if (!currentGift) return [];
    let candidates = MOCK_DB_GIFTS.filter(g => g.id !== id);
    return candidates.slice(0, 4).map(toDTO);
  },

  async getRecommendations(answers: QuizAnswers): Promise<RecommendationResponseDTO> {
    await delay(1200);
    // Simple mock logic: filter by gender/budget if possible, otherwise shuffle
    let filtered = [...MOCK_DB_GIFTS];
    
    // Rough budget filter
    const budget = parseInt(answers.budget.replace(/\D/g, ''));
    if (budget > 0) {
       filtered = filtered.filter(g => (g.price || 0) <= budget * 1.2); // +20% tolerance
    }

    // Gender check (simple heuristic via tags or category)
    if (answers.recipientGender === 'female') {
       // deprioritize overly masculine items (not strict in mock)
    }

    // Shuffle
    filtered = filtered.sort(() => 0.5 - Math.random());
    
    // Fallback if filter too aggressive
    if (filtered.length < 5) filtered = [...MOCK_DB_GIFTS].sort(() => 0.5 - Math.random());

    const resultGifts = filtered.slice(0, 12).map(toDTO);
    
    return {
      quiz_run_id: 'mock-uuid-' + Date.now(),
      engine_version: 'ranker_v1_mock',
      featured_gift: resultGifts[0],
      gifts: resultGifts,
      debug: { note: "Generated by MockServer" }
    };
  },

  async getWishlist(): Promise<string[]> {
    const stored = localStorage.getItem('gifty_wishlist');
    return stored ? JSON.parse(stored) : [];
  },

  async addToWishlist(giftId: string): Promise<void> {
    const stored = localStorage.getItem('gifty_wishlist');
    const list: string[] = stored ? JSON.parse(stored) : [];
    if (!list.includes(giftId)) {
        list.push(giftId);
        localStorage.setItem('gifty_wishlist', JSON.stringify(list));
    }
  },

  async removeFromWishlist(giftId: string): Promise<void> {
    const stored = localStorage.getItem('gifty_wishlist');
    const list: string[] = stored ? JSON.parse(stored) : [];
    const newList = list.filter(id => id !== giftId);
    localStorage.setItem('gifty_wishlist', JSON.stringify(newList));
  },

  async getUserProfile(): Promise<UserProfile> {
    const stored = localStorage.getItem('gifty_profile');
    if (!stored) {
       localStorage.setItem('gifty_profile', JSON.stringify(DEFAULT_PROFILE));
       return DEFAULT_PROFILE;
    }
    return JSON.parse(stored);
  },

  async updateUserProfile(data: Partial<UserProfile>): Promise<UserProfile> {
     const current = await this.getUserProfile();
     const updated = { ...current, ...data };
     localStorage.setItem('gifty_profile', JSON.stringify(updated));
     return updated;
  },

  async addEvent(event: Omit<CalendarEvent, 'id'>): Promise<CalendarEvent> {
    const profile = await this.getUserProfile();
    const newEvent = { ...event, id: Date.now().toString() };
    const updatedEvents = [...profile.events, newEvent].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    await this.updateUserProfile({ events: updatedEvents });
    return newEvent;
  },

  async removeEvent(id: string): Promise<void> {
    const profile = await this.getUserProfile();
    const updatedEvents = profile.events.filter(e => e.id !== id);
    await this.updateUserProfile({ events: updatedEvents });
  }
};